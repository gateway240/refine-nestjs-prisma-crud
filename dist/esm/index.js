var g=r=>{switch(r){case"and":return"AND";case"or":return"OR";case"eq":case"ne":case"lt":case"gt":case"lte":case"gte":case"in":case"nin":case"contains":case"ncontains":return"notIn";case"containss":case"ncontainss":case"null":case"nnull":case"startswith":case"startswiths":case"endswith":case"endswiths":default:return""}};var Q=r=>h({operator:"and",value:r}),h=r=>{if(r.operator!=="and"&&r.operator!=="or"&&"field"in r)return r.operator==="eq"?{[r.field]:r.value}:{[r.field]:{[g(r.operator)]:r.value}};let{operator:e}=r;return{[g(e)]:r.value.map(t=>h(t))}},$=(r,e)=>(e&&r&&(r.where=Q(e)),r);var f=(r,e)=>r;var x=(r,e)=>{let{current:t=1,pageSize:o=10,mode:a="server"}=e??{};return a==="server"&&(r.pageSize=o,r.page=t),r};var O=r=>{if(r&&r.length>0){let e=[];return r.map(({field:t,order:o})=>{t&&o&&e.push({field:t,order:o.toUpperCase()})}),e}},w=(r,e)=>{let t=O(e);return r};import P from"axios";var l=P.create();l.interceptors.response.use(r=>r,r=>{let e={...r,message:r.response?.data?.message,statusCode:r.response?.status};return Promise.reject(e)});var E=r=>{let e={};for(let t of r){let o=t.indexOf(" "),a=t.substring(0,o);e[a]?e[a].push(t):e[a]=[t]}return e};var p=r=>{let e=r.response.data.error,t=r.response.data.statusCode,o=r.response.data.message,a=E(o);return{statusCode:t,message:e,errors:a}};import{stringify as b}from"query-string";var S=(r,e=l)=>({getList:async({resource:t,pagination:o,filters:a,sorters:s,meta:n})=>{let u=`${r}/${t}`,c={};c=x(c,o),c=$(c,a);let{data:i}=await e.get(`${u}?${new URLSearchParams({crudQuery:JSON.stringify(c)})}`);return Array.isArray(i)?{data:i,total:i.length}:{data:i.data,total:i.totalRecords}},getMany:async({resource:t,ids:o,meta:a})=>{let s=`${r}/${t}`,n={};n=f(n,a?.join);let{data:u}=await e.get(`${s}?${new URLSearchParams({crudQuery:JSON.stringify(n)})}`);return{data:u}},create:async({resource:t,variables:o})=>{let a=`${r}/${t}`;try{let{data:s}=await e.post(a,o);return{data:s}}catch(s){throw p(s)}},update:async({resource:t,id:o,variables:a})=>{let s=`${r}/${t}/${o}`;try{let{data:n}=await e.patch(s,a);return{data:n}}catch(n){throw p(n)}},updateMany:async({resource:t,ids:o,variables:a})=>{let s=[],n=await Promise.all(o.map(async u=>{try{let{data:c}=await e.patch(`${r}/${t}/${u}`,a);return c}catch(c){let i=p(c);s.push(i)}}));if(s.length>0)throw s;return{data:n}},createMany:async({resource:t,variables:o})=>{let a=`${r}/${t}/bulk`;try{let{data:s}=await e.post(a,{bulk:o});return{data:s}}catch(s){throw p(s)}},getOne:async({resource:t,id:o,meta:a})=>{let s=`${r}/${t}/${o}`,n={};n=f(n,a?.join);let{data:u}=await e.get(`${s}?${new URLSearchParams({crudQuery:JSON.stringify(n)})}`);return{data:u}},deleteOne:async({resource:t,id:o})=>{let a=`${r}/${t}/${o}`,{data:s}=await e.delete(a);return{data:s}},deleteMany:async({resource:t,ids:o})=>({data:await Promise.all(o.map(async s=>{let{data:n}=await e.delete(`${r}/${t}/${s}`);return n}))}),getApiUrl:()=>r,custom:async({url:t,method:o,meta:a,filters:s,sorters:n,payload:u,query:c,headers:i})=>{let d={};d=f(d,a?.join),d=w(d,n);let y=`${t}?${new URLSearchParams({crudQuery:JSON.stringify(d)})}`;c&&(y=`${y}&${b(c)}`);let m;switch(o){case"put":case"post":case"patch":m=await e[o](t,u,{headers:i});break;case"delete":m=await e.delete(t,{data:u,headers:i});break;default:m=await e.get(y,{headers:i});break}let{data:C}=m;return Promise.resolve({data:C})}});var _=S;export{l as axiosInstance,h as createSearchQuery,_ as default,Q as generateSearchFilter,O as generateSort,$ as handleFilter,f as handleJoin,x as handlePagination,w as handleSort,g as mapOperator,E as transformErrorMessages,p as transformHttpError};
//# sourceMappingURL=index.js.map